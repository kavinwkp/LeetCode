## 进程基础知识

### 1、进程的概念

我们编译的可执行文件只是储存在硬盘的静态文件，运行时被加载到内存，CPU执行内存中指令，这个运行的程序被称为进程
进程是对运行时程序的封装，操作系统进行资源调度和分配的基本单位

### 2、进程的实现

>为了实现进程模型，操作系统维护着一张表格(一个结构数组)，即**进程表**

每个进程占有一个**进程表项**(有些著作称这些为**进程控制块**)
该表项包含了一个进程状态的重要信息，包括<font color=LightSeaGreen>程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号的调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息</font>，从而保证该进程随后能再次启动，就像从未中断过一样

### 3、并发与并行

1. 单个核心在很短时间内分别执行多个进程，称为并发
2. 多个核心同时执行多个进程称为并行
3. 对于并发来说，CPU需要从一个进程切换到另一个进程，这个过程需要保存进程的状态信息

#### 4、进程的状态

某个进程在某个时刻所处的状态分为以下几种，运行态、就绪态、阻塞态
对于阻塞状态，比如read系统调用阻塞，进程会占用内存空间，这是一种浪费行为，于是操作系统会有跟内存管理中物理⻚置换到磁盘一样的行为，把阻塞的进程置换到磁盘中，此时进程未占用物理内存，我们称之为**挂起**；挂起不仅仅可能是物理内存不足，比如sleep系统调用过着用户执行Ctrl+Z也可能导致挂起

除了创建和结束一般有三个状态

>+ 运行态： 该时刻进程占用CPU
>+ 就绪态： 可运行，由于其他进程处于运行状态而暂时停止运行
>+ 阻塞态： 该进程正在等待某一事件发生(如等待输入/输出操作的完成)而暂时停止运行

阻塞态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。

>+ 挂起态：新的状态，描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态
>   + 阻塞挂起状态： 进程在外存(硬盘)并等待某个事件的出现
>   + 就绪挂起状态： 进程在外存(硬盘)，但只要进入内存，⻢上运行

**特点**

>1. 就绪态和运行态可以相互转换，其它的都是单向转换。就绪态的进程通过调度算法从而获得CPU 时间，转为运行状态
>2. 运行态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度
>3. 阻塞态是缺少需要的资源从而由运行态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态

### 5、进程控制块(PCB)

操作系统对进程的感知，是通过进程控制块PCB数据结构来描述的。它是<font color=LightSeaGreen>进程存在的唯一标识</font>，其包括以下信息：

>1. 进程描述信息： 进程标识符、用户标识符等
>2. 进程控制和管理信息： 进程状态，进程优先级等
>3. 进程资源分配清单： 虚拟内存地址空间信息，打开文件列表，IO设备信息等
>4. CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执行该进程时能从断点处继续执行

PCB通过链表形式组织起来，比如有**就绪队列**、**阻塞队列**等，方便增删，方便进程管理。

### 6、进程状态的切换

进程的状态分类：

1. 就绪状态(ready)：等待被调度
2. 运行状态(running)
3. 阻塞状态(waiting)：等待资源

转换关系：

+ 只有就绪态和运行态可以互相转换，其他都是单向转换
+ 就绪态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程，在分配给它的CPU时间片完之后就会转为就绪状态，等待下一次调度
+ 进程因为等待资源而阻塞，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态
+ 当进程等待的外部事件发生时(如一些输入到达)，则由阻塞态转换为就绪态，如果此时没有其他进程运行，就转换为运行态，否则该进程将处于就绪态，等待CPU空闲轮到它运行

### 7、进程切换为何比线程慢

>涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换而线程不会

因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，所以同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

>把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是一个很慢的过程(至少访问2次内存)，因此通常使用Cache来缓存常用的地址映射，这样可以加速⻚表查找，这个Cache就是TLB(快表)

由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的⻚表，那么当进程切换后⻚表也要进行切换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，这也就是进程切换要比同进程下线程切换慢的原因

---

## 进程调度算法

### 1、批处理系统中的调度

>(1) 先来先服务

非抢占式的调度算法，按照请求的顺序进行调度
有利于⻓作业，但不利于短作业，因为短作业必须一直等待前面的⻓作业执行完毕才能执行，而⻓作业又需要执行很⻓时间，造成了短作业等待时间过⻓。

>(2) 最短作业优先

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。
⻓作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么⻓作业永远得不到调度

>(3) 最短剩余时间优先

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。
当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 2、交互式系统中的调度

>(1) 时间片轮转调度

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程

>(2) 优先级调度

为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

>(3) 多级队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次
多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8...。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次
每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程
可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合

>(4) 最短进程优先

如果我们将每一条命令的执行看作是一个独立的“作业”，则我们可以通过首先运行最短的作业来使响应事件最短